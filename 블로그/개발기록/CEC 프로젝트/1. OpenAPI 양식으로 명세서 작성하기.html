<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>1&period; &#xac1c;&#xc694;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="1-개요">1. 개요</h1>
<h2 id="1-1-문제-상황">1-1. 문제 상황</h2>
<p>프론트가 화면을 API 와 연동하면서, <strong>API 간의 일관성이 부족으로</strong> 프론트가 수정 요청하는 상황이 있었다.
<strong>관리자 웹</strong> API는 어떻게든 수정해서 프론트와 연동을 완료했지만, <strong>사용자 웹</strong> API는 <strong>관리자 웹</strong>보다도 훨씬 더 일관성이 떨어졌다.</p>
<p>문제 사례는 다음과 같다.</p>
<ol>
<li>페이지네이션 공통 응답 DTO 를 사용해야 하는데, JPA Pageable 을 그대로 응답하는 경우가 있었다.</li>
<li>모든 API 응답은, status, message, data 필드가 있어야 하는데, 그 규칙을 따르지 않은 경우가 있었다.</li>
<li>필드명이 일관성 없는 경우는 너무나 많았다.</li>
<li>필요한 API 가 없는 경우도 있었다. (게시글 좋아요 취소 / 조회)</li>
</ol>
<blockquote>
<p>당시 사용자 웹 API들을 보고싶으면,
<a href="https://editor.swagger.io/">Swagger Editor</a>에서 File &gt; Import URL을 클릭 후 <a href="https://raw.githubusercontent.com/CEC-project/CEC-Back/refs/heads/main/docs/user-api-docs-before.yaml">이 주소</a>를 붙여넣으면 된다.</p>
</blockquote>
<p>이대로라면 프론트는 물론 백엔드도 수정을 반복하며 고통받을것이 분명했다.
기한을 절대 맞출 수 없을 것이라는 확신이 들었고, 문제를 파악하고 해결해야겠다고 결심했다.</p>
<h2 id="1-2-문제-분석">1-2. 문제 분석</h2>
<ol>
<li>팀원중 한명이 노션에 작성한 API 명세서가 유명무실한 것이 가장 큰 원인이다. 왜 그랬을까?
<ul>
<li>기획이 변경될때, API 명세서가 최신화 되지 않았다.</li>
<li>노션 무료 워크스페이스 용량이 초과되어 더이상 작성할 수 없었다.</li>
<li>노션 명세서는 가독성이 떨어지는 문제가 있다.</li>
<li>팀원이 AI를 이용해 작성한 API 명세서라서, 빠진 필드나 기획에 맞지 않는 부분도 있었다.</li>
</ul>
</li>
<li>명세서가 문제면 다시 쓰면 되는데, 작성하는데 <strong>비용(=시간과 노력)</strong> 이 부담스러웠다.
<ul>
<li>문제를 해결하자고 결심한 떄를 기준으로, 13일후에 프로젝트를 마치자고 팀원들과 이야기가 되어있었다. 부족한점을 보완할 것까지 생각하면, 시간이 빠듯하다는 뜻이다.</li>
<li>API 엔드포인트 목록만 작성한다면 비용이 줄어 들겠지만, 심각한 문제들은 응답 필드들에서 발견되었으므로, API 응답에 대한 명세가 필요했다.</li>
<li>전문 기획자들은 보통 엑셀로 작성하지만, 모든 API 응답이 status, message, data 필드를 공통으로 가지고, 특히 조회 응답시에 DTO가 공통으로 쓰이는 상황이다. 이때 API 별로 각각의 필드명과 그 타입을 일일이 엑셀로 쓰자니 비용이 너무 많이 들 것이었다.</li>
</ul>
</li>
</ol>
<h2 id="1-3-문제-해결">1-3 문제 해결</h2>
<p>아래 문단에서 설명할 <strong>OpenAPI 명세서</strong>를 도입해서 위 문제를 해결하였다.</p>
<h1 id="2-openapi-란">2. OpenAPI 란?</h1>
<p><img src="file:////Users/sweetgrape/Documents/옵시디언/일기/블로그/개발기록/CEC 프로젝트/OpenAPI.png" alt="">
OpenAPI 는 API 명세서 양식중 하나로, yaml 또는 json 형식으로 작성된다.
아래는 간단한 예시이며, <a href="https://editor.swagger.io/">스웨거 에디터</a>에 붙여넣으면 보기 좋게 만들어준다.</p>
<pre><code class="language-yaml"><span class="hljs-attr">openapi:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.3</span>
<span class="hljs-attr">info:</span>
  <span class="hljs-attr">title:</span> <span class="hljs-string">Title</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
<span class="hljs-attr">paths:</span>
  <span class="hljs-string">/api/v1/posts/{id}:</span>
    <span class="hljs-attr">get:</span>
      <span class="hljs-attr">parameters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">id</span>
          <span class="hljs-attr">in:</span> <span class="hljs-string">path</span>
          <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>
          <span class="hljs-attr">schema:</span>
            <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span>
      <span class="hljs-attr">responses:</span>
        <span class="hljs-attr">&#x27;200&#x27;:</span>
          <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;OK&#x27;</span>
          <span class="hljs-attr">content:</span>
            <span class="hljs-attr">&#x27;application/json&#x27;:</span>
              <span class="hljs-attr">schema:</span>
                <span class="hljs-string">$ref:</span> <span class="hljs-string">&#x27;#/components/schemas/PostResponse&#x27;</span>
<span class="hljs-attr">components:</span>
  <span class="hljs-attr">schemas:</span>
    <span class="hljs-attr">PostResponse:</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>
      <span class="hljs-attr">properties:</span>
        <span class="hljs-attr">id:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span>
        <span class="hljs-attr">title:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>
        <span class="hljs-attr">content:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>
</code></pre>
<p>명세서가 yaml 이나 json 파일같은 텍스트 파일이므로, 다음과 같은 장점이 있다.</p>
<h2 id="2-1-버전관리가-쉽다">2-1. 버전관리가 쉽다.</h2>
<p>그냥 깃에 명세서 파일을 올리면, 누가 어떻게 수정했는지 관리할수 있다. <a href="https://github.com/CEC-project/CEC-Back/blob/main/docs/user-api-docs-after.yaml">예시</a></p>
<h2 id="2-2-명세서를-파싱해서-다루는-것이-쉽다">2-2. 명세서를 파싱해서 다루는 것이 쉽다.</h2>
<ol>
<li>명세서를 파싱해서 보기 좋게 만들어 줄수있다. <a href="https://swagger.io/tools/swagger-ui/">Swagger UI</a> <a href="https://github.com/swagger-api/swagger-ui">깃허브</a>.</li>
<li>명세서를 파싱해서 온갖 언어로 백엔드/프론트 코드를 자동 생성할수도 있다. <a href="https://github.com/OpenAPITools/openapi-generator">openapi-generator</a></li>
<li>본인이 담당하는 부분의 명세서만 볼수있게 분할시킬 수도 있다. <a href="https://github.com/qkr10/openapi-splitter">내가 짠 코드</a>. <a href="https://github.com/CEC-project/CEC-Back/tree/main/docs/after">결과 예시</a></li>
</ol>
<h2 id="2-3-백엔드-코드로부터-역으로-명세서를-생성할수도-있다">2-3. 백엔드 코드로부터 역으로 명세서를 생성할수도 있다.</h2>
<p><a href="https://github.com/springdoc/springdoc-openapi">springdoc-openapi</a> 라이브러리를 사용하면,</p>
<ol>
<li>OpenAPI 양식의 명세서 자동 생성</li>
<li>Swagger UI 로 명세서를 보기좋게 만들어줌 <a href="https://dev.api.bmvcec.store/swagger-ui/index.html">예시</a>
을 자동으로 해준다.</li>
</ol>
<blockquote>
<p>위의 <code>2-2-1</code>, <code>2-2-2</code>, <code>2-3</code> 기능은 Intellij에서도 <a href="https://www.jetbrains.com/help/idea/openapi.html">지원</a>된다.</p>
</blockquote>
<h1 id="3-swagger-ui-란">3. Swagger UI 란?</h1>
<p><img src="file:////Users/sweetgrape/Documents/옵시디언/일기/블로그/개발기록/CEC 프로젝트/swagger_logo.svg" alt="">
Swagger UI 는 OpenAPI 양식의 명세서를 보기 좋게 시각화해주는 JavaScript 라이브러리이다.</p>
<p>다양한 옵션을 전달하여 사용자가 필요에 맞게 설정할 수도 있다. (<a href="https://swagger.io/docs/open-source-tools/swagger-ui/usage/installation/">공식 문서</a>)</p>
<ul>
<li>API를 <strong>태그순 / 경로순 / 메서드순</strong>으로 정렬하는 옵션</li>
<li>각 섹션을 <strong>접기/펼치기</strong> 설정하는 옵션 등</li>
</ul>
<blockquote>
<p>나는 위와같은 Swagger UI의 설정들을 사용자가 <strong>GUI로 직접 선택</strong>할 수 있도록 만들고,
해당 설정을 <strong>쿠키에 저장하여 자동으로 불러오는 편의 기능</strong>을 구현해 보았다.
<a href="https://github.com/CEC-project/CEC-Back/tree/565808907505abe4fd0997315cdc05bcc9d1e422/src/main/resources/META-INF/resources/webjars/swagger-ui">직접 작성한 JS 코드</a>.
<a href="https://dev.api.bmvcec.store/swagger-ui/index.html">예시</a>.</p>
</blockquote>
<h1 id="4-결론">4. 결론</h1>
<h2 id="4-1-openapi-명세서를-도입해-해결한-문제들">4-1. OpenAPI 명세서를 도입해 해결한 문제들</h2>
<ol>
<li>노션 워크스페이스 용량 초과 문제
<ul>
<li>git과 github를 사용하여 OpenAPI 명세서를 저장하여 해결</li>
</ul>
</li>
<li>노션 명세서 가독성 문제
<ul>
<li>Swagger UI 나 인텔리제이 내장기능으로 보기좋게 만들어서 해결</li>
</ul>
</li>
<li>API 일관성 부족 문제
<ul>
<li>내가 명세서를 작성하고, 코드리뷰 시 명세서 기준으로 확인하여 해결
내가 작성한 명세서와 자동 생성된 명세서가 동일한 양식이므로, 검사하는 비용이 매우 줄어듬</li>
</ul>
</li>
<li>명세서를 다시 작성하는 비용 문제
<ul>
<li>기존 백엔드 코드로 자동 생성된 명세서를, 필요한 부분만 수정하는 방식으로 해결</li>
</ul>
</li>
</ol>
<h2 id="4-2-아쉬웠던-점--한계">4-2. 아쉬웠던 점 &amp; 한계</h2>
<ol>
<li>팀원들이 코드리뷰를 거쳐야지만 내가 명세서에 적은대로 수정해 주었다.
<ul>
<li>yaml 명세서 간에 <a href="https://wepplication.github.io/tools/compareDoc/">diff를 보여줄 수 있는 사이트</a>를 소개하고, <a href="https://www.jetbrains.com/help/idea/openapi.html">intellij로 편하게 볼 수 있다</a>고 <a href="https://github.com/CEC-project/CEC-Back/blob/565808907505abe4fd0997315cdc05bcc9d1e422/docs/api-rule.md">전파</a>했다. 하지만 springdoc-openapi 로 자동 생성된 yaml 명세서를 보는법은 충분히 설명하지 못했다.</li>
<li>다시 그떄로 돌아간다면, 디스코드에서 직접 시연했을 것 같다. 사실 보기 좋게 띄우는 방법만 안다면, 작업한 내용이 명세서와 일치하는지 금방 확인할수 있다.</li>
</ul>
</li>
<li>OpenAPI 명세서로 코드를 자동 생성할 수 있지만, 기존 아키텍처에 맞춰 적용하려면 노하우가 필요하다.
<ul>
<li>코드를 자동 생성해주는 프로그램들은, 요청/응답 타입 코드와, API 테스트해주는 코드 수준에 그친다.</li>
<li>결과물을 정규식을 사용해 변형하거나, 아니면 생성기 자체의 코드를 수정하거나.. 이런 비용이 추가적으로 들것 같다.</li>
</ul>
</li>
<li>노션/엑셀 기반 명세서에 비해, 명세서를 직접 작성하기 위한 <a href="https://swagger.io/specification/">사전지식</a>이 너무 많다.
<ul>
<li>물론 기존 명세서와 큰틀에서 같기 때문에, 조금만 알려주면 누구나 쓸수 있다고 생각한다.</li>
</ul>
</li>
<li>애초에 이런 일이 안생기는게 맞았다.
<ul>
<li>팀이 만들어지고 나중에 합류하긴 했지만, 이렇게 심각한 문제가 될것을 내가 미리 알았더라면, 훨씬 적은 비용으로 해결할 수 있었을 것이다.</li>
</ul>
</li>
</ol>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>